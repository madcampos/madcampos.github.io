import f from"./default-styles.json.proxy.js";import g from"./default-decorators.json.proxy.js";export function decorateNonCombiningMark(e,r){return/\p{Mark}|\s/giu.test(e)?e:`${e}${r}`}export function encloseNonCombiningMark(e,r,n){return/\p{Mark}|\s/giu.test(e)?e:`${r}${e}${n}`}export function stripCombiningMark(e){return/\p{Mark}/giu.test(e)?"":e}export function createMappingFunction(e){return(r,n=!0)=>{let t=[...r];return n&&(t=t.map(stripCombiningMark).filter(o=>o!=="")),[...t].map(o=>e.get(o)??e.get(o.toLowerCase())??o).join("")}}export function createTransformationFunction(e){return(r,n=!0)=>{let t=[...r];return n&&(t=t.map(stripCombiningMark).filter(o=>o!=="")),[...t].map(e).join("")}}const s={...Object.entries(f).reduce((e,[r,n])=>(e[r]=createMappingFunction(new Map(n)),e),{}),Parens:createTransformationFunction(e=>encloseNonCombiningMark(e,"〖","〗")),Wavy:createTransformationFunction(e=>encloseNonCombiningMark(e,"〰","〰")),Brackets:createTransformationFunction(e=>encloseNonCombiningMark(e,"〔","〕")),"Angle Brackets":createTransformationFunction(e=>encloseNonCombiningMark(e,"《","》")),Enclosed:createTransformationFunction(e=>encloseNonCombiningMark(e,"『","』")),"Semi Enclosed":createTransformationFunction(e=>encloseNonCombiningMark(e,"【","】")),"Double Lined":createTransformationFunction(e=>decorateNonCombiningMark(e,"̲̅")),Hearts:createTransformationFunction(e=>decorateNonCombiningMark(e,"♥")),Striked:createTransformationFunction(e=>decorateNonCombiningMark(e,"̶")),Deleted:createTransformationFunction(e=>decorateNonCombiningMark(e,"̸")),"Camel Case":createTransformationFunction((e,r)=>r%2==0?e.toUpperCase():e.toLowerCase()),Inverted:e=>[...e].reverse().join(""),Matrix:createTransformationFunction(e=>{const r=7,t=["̿","͇","͇̿","̅","̲","̲̅","̶","͇"][Math.floor(Math.random()*r)];return decorateNonCombiningMark(e,t)}),"Double Letters":createTransformationFunction(e=>decorateNonCombiningMark(e,e)),"Double Some Letters":createTransformationFunction(e=>{const r=2,n=Math.floor(Math.random()*r);return decorateNonCombiningMark(e,e.repeat(n))})},d={...Object.entries(g).reduce((e,[r,n])=>(e[r]=n,e),{}),"Next Year":{left:(new Date().getFullYear()+1).toString(),right:(new Date().getFullYear()+1).toString()},"Current Year":{left:new Date().getFullYear().toString(),right:new Date().getFullYear().toString()},"New Year":{left:s["Lower Numbers"](new Date().getFullYear().toString()),right:s["Upper Numbers"]((new Date().getFullYear()+1).toString())}};export class TextDecorator{constructor(r=s,n=d){this.#t=new Map,this.#e=new Map,this.addStyle=(t,o)=>this.#t.set(t,o),this.removeStyle=t=>this.#t.delete(t),this.listStyles=()=>[...this.#t.keys()],this.getStyle=t=>this.#t.get(t),this.addDecorator=(t,o)=>this.#e.set(t,o),this.removeDecorator=t=>this.#e.delete(t),this.listDecorators=()=>[...this.#e.keys()],this.getDecorator=t=>this.#e.get(t);for(const[t,o]of Object.entries(r))this.addStyle(t,o);for(const[t,o]of Object.entries(n))this.addDecorator(t,o)}#t;#e;decorateText(r,n="nostyle",t={}){const o={leftDecorator:"",rightDecorator:"",normalizeResult:!1,stripAccents:!0,...t},u=this.#e.get(o.leftDecorator)?.left??"",c=this.#e.get(o.rightDecorator)?.right??"",i=r.normalize("NFD"),a=this.#t.get(n)?.(i,o.stripAccents)??i;let l=a;return o.normalizeResult&&(l=a.normalize("NFC")),`${u}${l}${c}`}}
